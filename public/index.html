<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Bad Hanabi</title>
    <script defer src="/__/firebase/5.8.3/firebase-app.js"></script>
    <script defer src="/__/firebase/5.8.3/firebase-auth.js"></script>
    <script defer src="/__/firebase/5.8.3/firebase-firestore.js"></script>
    <script defer src="/__/firebase/init.js"></script>
    <script defer src="https://unpkg.com/mithril/mithril.js"></script>
    <script defer src="https://unpkg.com/lodash/lodash.js"></script>
    <script>
    const COLORS = ['R', 'G', 'B', 'Y', 'W', 'P'];
    function generateDeck() {
      let tiles = [];
      COLORS.forEach(c => {
        tiles.push(`${c}1`);
        tiles.push(`${c}1`);
        tiles.push(`${c}1`);
        tiles.push(`${c}2`);
        tiles.push(`${c}2`);
        tiles.push(`${c}3`);
        tiles.push(`${c}3`);
        tiles.push(`${c}4`);
        tiles.push(`${c}4`);
        tiles.push(`${c}5`);
      });
      return _.shuffle(tiles);
    }
    function handSize(numPlayers) {
      switch (numPlayers) {
        case 2: return 6;
        case 3: return 5;
        case 4: return 4;
        case 5: return 4;
        default: return -1;
      }
    }
    function drawTiles(tiles, num_tiles) {
      let ts = [];
      for (let i=0; i < num_tiles; i++) {
        ts.push({ tile: tiles.pop() });
      }
      return ts;
    }

    const ROOM_STATES = {
      WAITING_TO_START: "waiting to start",
    };
    const EMPTY_ROOM = {
      players: [],
      state: ROOM_STATES.WAITING_TO_START,
    };

    function viewModel(model, handler) {
      return m("main", [
        m('div', { id: "whoami", }, `You are: ${model.uid}`),
        m('div', { id: "state", }, model.room.state),

        m('div', {
          id: "players",
        }, [
          "Players:",
          model.room.players.map(player => {
            if (!model.room.hands) {
              return m('p', player);
            }
            const hand = viewHand(model.room.hands[player], player === model.uid);
            return m('p', [ player, hand ]);
          })
        ]),

        m('input', {
          id: "user_input",
          onchange: handler,
          placeholder: "user_input goes here",
        }),

        m('div', {
          id: "messages",
        }, model.messages.map(msg => m('p', msg))),
      ]);
    }
    function viewHand(hand, hide_tiles) {
      return m('ol', hand.map(item => viewHandItem(item, hide_tiles)));
    }
    function viewHandItem(item, hide_tiles) {
      return item.tile
        ? viewTile(item, hide_tiles)
        : viewHint(item.hint);
    }
    function viewTile(tile, hide_tiles) {
      return hide_tiles
        ? m('p', "HIDDEN")
        : m('p', tile.tile);
    }
    function viewHint(hint) {
      return m('p', hint);
    }
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const room_id = window.location.pathname.substring(1);
        let model = {
          messages: [],
          room: {
            players: [],
            state: "initializing...",
          },
        };
        model.view = () => viewModel(model, handler);

        function log(msg) {
          model.messages.push(msg);
          return true;
        }

        const app = firebase.app();
        app.auth().onAuthStateChanged(evt => {
          model.uid = evt.uid;
          if (model.uid) {
            app.firestore().collection("rooms").doc(room_id).update({
              players: firebase.firestore.FieldValue.arrayUnion(model.uid),
            });
          }
        });
        const remote = {
          room: app.firestore().collection("rooms").doc(room_id),
          actions: app.firestore().collection("rooms").doc(room_id).collection("actions"),
        };
        remote.room.onSnapshot(snap => {
          console.log("room: ", snap);
          if (snap.exists) {
            model.room = snap.data();
            m.redraw();
          } else {
            remote.room.set(EMPTY_ROOM);
          }
        });

        function help() {
          if (!model.uid) {
            return log("you're not logged in yet, this should happen automatically");
          }
          if (!model.room) {
            return log("waiting for room to load, this should happen automatically");
          }
          if (model.room.players.indexOf(model.uid) === -1) {
            return log("you're currently observing this game, try /join if you want to play");
          }
          if (model.room.state === ROOM_STATES.WAITING_TO_START) {
            return log("this game hasn't started yet, try /start");
          }
          return log("[UNREACHABLE] this shit is busted, my bad");
        }
        function startGame() {
          if (!model.room.state) {
            return log("can't start until you've joined a room");
          } 
          if (model.room.state != ROOM_STATES.WAITING_TO_START) {
            return log(`game has already started`);
          }

          const hand_size = handSize(model.room.players.length);
          if (hand_size < 0) {
            return log(`wrong number of players, we can support 2--5, you have ${model.room.players.length}`);
          }
          let deck = generateDeck();
          let hands = {};
          model.room.players.forEach(player => {
            hands[player] = drawTiles(deck, hand_size);
          });
          remote.room.update({
            draw_pile: deck,
            discard_pile: [],
            hands,
            state: `waiting for ${model.room.players[0]}`
          });
          return log("game has begun!");
        }
        const commands = {
          help: help,
          start: startGame,
        };
        function perform(action) {
          if (!model.uid) {
            console.warn("not logged in");
            return false;
          }
          for (cmd in commands) {
            if (action.startsWith(`/${cmd}`)) {
              const args = action.substring(cmd.length + 1).trim().split(/\s+/);
              return commands[cmd].apply(null, args);
            }
          }
          console.warn(`${action} does not match any of ${Object.keys(commands)}`);
          return false;
        }

        app.auth().signInAnonymously();
        function handler(evt) {
          const v = evt.srcElement.value;
          if (perform(v)) {
            evt.srcElement.value = "";
          } else {
            console.warn("invalid action: ", v);
          }
        }
        m.mount(document.body, model);
      });
    </script>
</html>
