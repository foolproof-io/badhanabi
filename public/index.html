<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Bad Hanabi</title>
    <style>
    img {
      width: 40px;
    }
    td {
      width: 50px;
      text-align: center;
    }
    </style>
    <script defer src="/__/firebase/5.8.3/firebase-app.js"></script>
    <script defer src="/__/firebase/5.8.3/firebase-auth.js"></script>
    <script defer src="/__/firebase/5.8.3/firebase-firestore.js"></script>
    <script defer src="/__/firebase/init.js"></script>
    <script defer src="https://unpkg.com/mithril/mithril.js"></script>
    <script defer src="https://unpkg.com/lodash/lodash.js"></script>
    <script>
    const COLORS = ['R', 'G', 'B', 'Y', 'W', 'P'];
    const RANKS = ['1', '2', '3', '4', '5'];
    function generateDeck() {
      let tiles = [];
      COLORS.forEach(c => {
        tiles.push(`${c}1`);
        tiles.push(`${c}1`);
        tiles.push(`${c}1`);
        tiles.push(`${c}2`);
        tiles.push(`${c}2`);
        tiles.push(`${c}3`);
        tiles.push(`${c}3`);
        tiles.push(`${c}4`);
        tiles.push(`${c}4`);
        tiles.push(`${c}5`);
      });
      return _.shuffle(tiles);
    }
    function handSize(numPlayers) {
      switch (numPlayers) {
        case 2: return 6;
        case 3: return 5;
        case 4: return 4;
        case 5: return 4;
        default: return -1;
      }
    }
    const NUM_INITIAL_HINTS = 8;
    function drawTiles(tiles, num_tiles) {
      let ts = [];
      for (let i=0; i < num_tiles; i++) {
        ts.push({ tile: tiles.pop(), hints: [] });
      }
      return ts;
    }

    function playerAfter(players, p) {
      const idx = players.indexOf(p);
      return players[(idx + 1) % players.length];
    }

    function isLegalPlay(played, tile) {
      const color = tile[0];
      let highest_of_color = 0;
      played.forEach(p => {
        if (p[0] == color && Number(p[1]) > highest_of_color) {
          highest_of_color = Number(p[1]);
        }
      });
      return Number(tile[1]) === highest_of_color + 1;
    }
    function applyHintToHand(hand, hint) {
      let applied = hand.map(item => {
        if (item.tile && matchesHint(item.tile, hint)) {
          item.hints.push(hint);
        }
        return item;
      });
      applied.push({ hint });
      return applied;
    }

    function applyDiscardToHand(hand, idx) {
      return hand.slice(0, idx).concat(hand.slice(idx+1));
    }

    function matchesHint(tile, hint) {
      return tile.indexOf(hint) !== -1;
    }

    const ROOM_STATES = {
      WAITING_TO_START: "waiting to start",
      WAITING_FOR_PLAYER: player => `waiting for ${player}`,
    };
    function viewModel(model, handler) {
      return m("main", [
        m('div', { id: "whoami", }, `You are: ${model.uid}`),
        m('div', { id: "state", }, model.room.state || "waiting to start"),
        m('div', { id: "hints", }, `Hints: ${model.room.hints}`),
        m('div', { id: "errors", }, `Errors: ${model.room.errors}`),
        m('div', { id: "discards", }, `Discards: ${model.room.discard_pile}`),
        m('div', { id: "plays", }, `Plays: ${model.room.play_pile}`),

        m('div', {
          id: "players",
        }, [
          "Players:",
          (model.room.players || []).map(player => {
            if (!model.room.hands) {
              return m('p', player);
            }
            const hand = viewHand(model.room.hands[player], player === model.uid);
            return m('p', [ player, hand ]);
          })
        ]),

        m('input', {
          id: "user_input",
          onchange: handler,
          placeholder: "user_input goes here",
        }),

        m('div', {
          id: "messages",
        }, model.messages.map(msg => m('p', msg)).reverse()),
      ]);
    }
    function viewHand(hand, hide_tiles) {
      return m('table', [
        m('tr', hand.map((item, idx) => m('td', idx))),
        m('tr', hand.map(item => m('td', viewHandItem(item, hide_tiles)))),
      ]);
    }
    function viewHandItem(item, hide_tiles) {
      return item.tile
        ? viewTile(item, hide_tiles)
        : viewHint(item.hint);
    }
    function viewTile(tile, hide_tiles) {
      return m('div', [
        m('img', { src: `./imgs/tiles/${hide_tiles ? "uu" : tile.tile.toLowerCase()}.svg` }),
        m('br'),
        `[${tile.hints}]`
      ]);
    }
    function viewHint(hint) {
      return m('p', hint);
    }
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const room_id = window.location.pathname.substring(1);
        let model = {
          messages: [],
          room: {},
        };
        model.view = () => viewModel(model, handler);

        function log(msg) {
          model.messages.push(msg);
          return true;
        }

        const app = firebase.app();
        app.auth().onAuthStateChanged(evt => {
          model.uid = evt.uid;
          if (model.uid) {
            remote.room.set({
              players: firebase.firestore.FieldValue.arrayUnion(model.uid),
            }, {merge:true});
          }
        });
        const remote = {
          room: app.firestore().collection("rooms").doc(room_id),
          actions: app.firestore().collection("rooms").doc(room_id).collection("actions"),
        };
        remote.room.onSnapshot(snap => {
          console.log("room: ", snap);
          if (snap.exists) {
            model.room = snap.data();
            m.redraw();
          }
        });

        function help() {
          if (!model.uid) {
            return log("you're not logged in yet, this should happen automatically");
          }
          if (!model.room) {
            return log("waiting for room to load, this should happen automatically");
          }
          if (!model.room.state) {
            return log("this game hasn't started yet, try /start");
          }
          if (model.room.state !== ROOM_STATES.WAITING_FOR_PLAYER(model.uid)) {
            return log("it's not your turn right now");
          }
          return log("you can /discard <tile_idx>, /play <tile_idx>, or /hint <player> <hint>");
        }
        function startGame() {
          if (model.room.state) {
            return log(`game has already started`);
          }

          const hand_size = handSize(model.room.players.length);
          if (hand_size < 0) {
            return log(`wrong number of players, we can support 2--5, you have ${model.room.players.length}`);
          }
          let deck = generateDeck();
          let hands = {};
          model.room.players.forEach(player => {
            hands[player] = drawTiles(deck, hand_size);
          });
          remote.room.update({
            draw_pile: deck,
            discard_pile: [],
            play_pile: [],
            hints: NUM_INITIAL_HINTS,
            errors: 0,
            hands,
            state: ROOM_STATES.WAITING_FOR_PLAYER(model.room.players[0]),
          });
          return log("game has begun!");
        }
        function discardTile(idx_str) {
          if (model.room.state !== ROOM_STATES.WAITING_FOR_PLAYER(model.uid)) {
            return log("not your turn");
          }
          const idx = Number(idx_str);
          const hand = model.room.hands[model.uid];
          if (!hand[idx] || !hand[idx].tile) {
            return log(`can't discard that, try again`);
          }
          let update = {};
          update.state = ROOM_STATES.WAITING_FOR_PLAYER(playerAfter(model.room.players, model.uid));
          update.hints = model.room.hints + 1;
          update.discard_pile = model.room.discard_pile.concat(hand[idx].tile);
          const next_tile = model.room.draw_pile[0];
          if (next_tile) {
            update.draw_pile = model.room.draw_pile.slice(1);
            update[`hands.${model.uid}`] = applyDiscardToHand(hand, idx).concat({
              tile: next_tile,
              hints: [],
            });
          }
          remote.room.update(update);
          return log(`discarding ${hand[idx].tile}`);
        }
        function playTile(idx_str) {
          if (model.room.state !== ROOM_STATES.WAITING_FOR_PLAYER(model.uid)) {
            return log("not your turn");
          }
          const idx = Number(idx_str);
          const hand = model.room.hands[model.uid];
          if (!hand[idx] || !hand[idx].tile) {
            return log(`can't play that, try again`);
          }
          let update = {};
          update.state = ROOM_STATES.WAITING_FOR_PLAYER(playerAfter(model.room.players, model.uid));
          if (isLegalPlay(model.room.play_pile, hand[idx].tile)) {
            update.play_pile = model.room.play_pile.concat(hand[idx].tile);
          } else {
            update.errors = model.room.errors + 1;
            update.discard_pile = model.room.discard_pile.concat(hand[idx].tile);
          }
          const next_tile = model.room.draw_pile[0];
          if (next_tile) {
            update.draw_pile = model.room.draw_pile.slice(1);
            update[`hands.${model.uid}`] = applyDiscardToHand(hand, idx).concat({
              tile: next_tile,
              hints: [],
            });
          }
          remote.room.update(update);
          return log(`playing ${hand[idx].tile}`);
        }
        function giveHint(target_prefix, hint) {
          if (model.room.state !== ROOM_STATES.WAITING_FOR_PLAYER(model.uid)) {
            return log("not your turn");
          }
          if (model.hints === 0) {
            return log("no hints left");
          }
          const matching_players = model.room.players
                                .filter(p => p !== model.uid && p.startsWith(target_prefix));
          if (matching_players.length === 0) {
            return log("prefix doesn't match any of the others players");
          }
          if (matching_players.length > 1) {
            return log(`prefix matches ${matching_players.length} players`);
          }
          const target_player = matching_players[0];
          if (model.room.players.indexOf(target_player) === -1) {
            return log("no such player");
          }
          const h = hint.toUpperCase(); // canonicalize to uppercase
          if (h.length !== 1 || COLORS.indexOf(h) === -1 && RANKS.indexOf(h) === -1) {
            return log("invalid hint");
          }
          let update = {};
          update.state = ROOM_STATES.WAITING_FOR_PLAYER(playerAfter(model.room.players, model.uid));
          update.hints = model.room.hints - 1;
          update[`hands.${target_player}`] = applyHintToHand(model.room.hands[target_player], h);
          remote.room.update(update);
          return log(`telling ${target_player} about ${hint}`);
        }
        const commands = {
          help: help,
          start: startGame,
          hint: giveHint,
          discard: discardTile,
          play: playTile,
        };
        function perform(action) {
          if (!model.uid) {
            console.warn("not logged in");
            return false;
          }
          for (cmd in commands) {
            if (action.startsWith(`/${cmd}`)) {
              const args = action.substring(cmd.length + 1).trim().split(/\s+/);
              commands[cmd].apply(null, args);
              return true;
            }
          }
          console.warn(`${action} does not match any of ${Object.keys(commands)}`);
          return false;
        }

        app.auth().signInAnonymously();
        function handler(evt) {
          const v = evt.srcElement.value;
          if (perform(v)) {
            evt.srcElement.value = "";
          } else {
            console.warn("invalid action: ", v);
          }
        }
        m.mount(document.body, model);
      });
    </script>
</html>
